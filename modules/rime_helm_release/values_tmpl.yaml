rime:
  domain: "${domain}"
  verbose: ${verbose}
  acmCertArn: ${acm_cert_arn}
%{ if length(ip_allowlist) > 0 ~}
  ipAllowlist:
%{ for ip in ip_allowlist ~}
  - ${ip}
%{ endfor ~}
%{ endif ~}
  enableApiKeyAuth: ${enable_api_key_auth}
  separateModelTestingGroup: ${separate_model_testing_group}

autoscaling:
  enabled: true
  minReplicas: 1
  maxReplicas: 10
  targetMemoryUtilizationPercentage: 80
  targetCPUUtilizationPercentage: 80
replicaCount: 3 #Ignored if autoscaling enabled.

resources:
  requests:
    memory: "100Mi"
    cpu: "100m"
  limits:
    memory: "500Mi"
    cpu: "500m"

modelTestResources:
  requests:
    memory: "4000Mi"
    cpu: "1500m"

backendImage:
  name: "${docker_registry}/${docker_backend_image}:${version}"
  pullPolicy: "${pull_policy}"

frontendImage:
  name: "${docker_registry}/${docker_frontend_image}:${version}"
  pullPolicy: "${pull_policy}"

modelTestImage:
  # This is the rime-engine configuration for the staging environment.
  name: "${docker_registry}/${docker_model_testing_image}:${version}"
  pullPolicy: "${pull_policy}"

firewall:
  enabled: true

scheduledCT:
  scheduledCTCRON:
      create: ${create_scheduled_ct}
      # run every five minutes
      schedule: "*/5 * * * *"

# TODO(blaine): Allow image pull secrets to be customized to the image.
imagePullSecrets:
  - name: ${docker_secret_name}

rimeJwt: ${rime_jwt}

userpilotFlow: "${user_pilot_flow}"

mongodb:
  image:
    registry: "${docker_registry}"
    repository: "robustintelligencehq/mongodb"
    tag: "5.0.9-debian-11-r7"
    pullSecrets:
      - ${docker_secret_name}
  podAnnotations:
    cluster-autoscaler.kubernetes.io/safe-to-evict: "false"
    ad.datadoghq.com/mongodb.check_names: '["mongo"]'
    ad.datadoghq.com/mongodb.init_configs: '[{}]'
%{ if enable_additional_mongo_metrics ~}
    ad.datadoghq.com/mongodb.instances: |
      [
        {
          "hosts": ["%%host%%:%%port%%"],
          "database": "rime-store",
          "additional_metrics": ["collection"],
          "collections": ["project", "docstore-notif-setting", "docstore-firewall", "UserV0"]
        }
      ]
%{ else ~}
    ad.datadoghq.com/mongodb.instances: |
      [
        {
          "hosts": ["%%host%%:%%port%%"],
          "database": "rime-store"
        }
      ]
%{ endif ~}
    ad.datadoghq.com/mongodb.logs: '[{"source":"mongodb","service":"mongodb"}]'
  persistence:
    enabled: true
    storageClass: "${mongo_storage_class}"
    size: "${mongo_db_size}"

# The following overrides are AWS specific.
imageRegistry:
  create: ${image_registry_config.registry_type != null}
%{ if image_registry_config.registry_type != null ~}
  config:
    imageRegistry:
%{ if image_registry_config.registry_type == "ecr" ~}
      ecr:
        registryID: "${image_registry_config.ecr_config.registry_id}"
        repositoryPrefix: "${image_registry_config.ecr_config.repository_prefix}"
%{ endif ~}
%{ if image_registry_config.registry_type == "gar" ~}
      gar:
        location: "${image_registry_config.gar_config.location}"
        project: "${image_registry_config.gar_config.project}"
        repository: "${image_registry_config.gar_config.repository}"
%{ endif ~}
  dockerSecretName: "${docker_secret_name}"
  # Specification of the container image used for running the image builder jobs.
  image:
    name: "${docker_registry}/${docker_image_builder_image}:${version}"
    pullPolicy: "${pull_policy}"
  rbac:
    serverAccount:
      # Annotations required to associate the image registry server account
      # with the AWS IAM role used to create, access and modify RIME's ECR repositories.
      annotations: {
        eks.amazonaws.com/role-arn: ${image_registry_config.repo_manager_role_arn}
      }
    jobAccount:
      # Annotations required to associate the image builder job account
      # with the AWS IAM role used to push and pull images to RIME's ECR repositories.
      annotations: {
        eks.amazonaws.com/role-arn: ${image_registry_config.image_builder_role_arn}
      }
%{ endif ~}

modelTesting:
  allowExternalCustomImages: ${image_registry_config.allow_external_custom_images}
%{ if length(model_test_job_config_map) > 0 ~}
  configMapName: ${ model_test_job_config_map }
%{ endif ~}

blobStore:
  rbac:
    create: ${use_blob_store}
    blobStoreAccount:
      create: ${use_blob_store}
      # Account used by services that need access to blob storage.
      # This account has special priveleges to read and write to S3 bucket used for blob storage.
      annotations: {
        eks.amazonaws.com/role-arn: ${s3_blob_store_role_arn}
      }
  # The bucket name of the S3 bucket used as the blob storage.
  storageBucketName: ${s3_blob_store_bucket_name}
  endpoint: "s3.amazonaws.com"
  type: "s3"

ingress-nginx:
  imagePullSecrets:
    - name: ${docker_secret_name}
  controller:
    image:
      registry: "${docker_registry}"
      image: "robustintelligencehq/ingress-nginx-controller"
      tag: "v1.3.1"
      digest: "sha256:d3642f55a6a7a102a9a579b3382fe73869c73890de4c94f28e36ba5e07925944"
    scope:
      enabled: true
      namespace: ${namespace}
    service:
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "${acm_cert_arn}"
        service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "https"
        service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "3600"
        service.beta.kubernetes.io/aws-load-balancer-type: "external"
        service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "tcp"
        service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: "ip"
        service.beta.kubernetes.io/aws-load-balancer-scheme: "${lb_type}"
%{ if length(ip_allowlist) > 0 ~}
        service.beta.kubernetes.io/aws-load-balancer-target-group-attributes: preserve_client_ip.enabled=true
%{ endif ~}
%{ if length(lb_security_groups) > 0 ~}
        ${lb_security_groups}
%{ endif ~}
%{ if length(lb_tags) > 0 ~}
        ${lb_tags}
%{ endif ~}

kong:
  image:
    repository: "${docker_registry}/robustintelligencehq/kong"
    tag: "2.8"
    pullSecrets:
      - ${docker_secret_name}
  ingressController:
    image:
      repository: "${docker_registry}/robustintelligencehq/kong-kubernetes-ingress-controller"
      tag: "2.2"
    watchNamespaces:
      - ${namespace}
  proxy:
    annotations:
      service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "${acm_cert_arn}"
      service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "kong-proxy-tls"
      service.beta.kubernetes.io/aws-load-balancer-type: "external"
      service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "*"
      service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: "ip"
      service.beta.kubernetes.io/aws-load-balancer-scheme: "${lb_type}"
      service.beta.kubernetes.io/aws-load-balancer-alpn-policy: "HTTP2Preferred"
%{ if length(ip_allowlist) > 0 ~}
      service.beta.kubernetes.io/aws-load-balancer-target-group-attributes: preserve_client_ip.enabled=true
%{ endif ~}
%{ if length(lb_security_groups) > 0 ~}
      ${lb_security_groups}
%{ endif ~}
%{ if length(lb_tags) > 0 ~}
      ${lb_tags}
%{ endif ~}

redis:
  image:
    registry: "${docker_registry}"
    repository: "robustintelligencehq/redis"
    tag: "7.0.4-debian-11-r4"
    pullSecrets:
      - ${docker_secret_name}


datasetManager:
  useFileUploadService: ${use_file_upload_service}

rmqHealth:
  create: ${use_rmq_health}
  resourceCleaner:
    create: ${use_rmq_resource_cleaner}
    frequency: ${rmq_resource_cleaner_frequency}
  metricsUpdater:
    create: ${use_rmq_metrics_updater}
    frequency: ${rmq_metrics_updater_frequency}

databaseSetup:
  initClusterMetadataHook:
    overwriteLicense: ${overwrite_license}

vault:
  global:
    imagePullSecrets:
      - name: ${docker_secret_name}
  injector:
    image:
      registry: "docker.io"
      repository: "robustintelligencehq/vault-k8s"
      tag: "v1.0"
  server:
    image:
      registry: "docker.io"
      repository: "robustintelligencehq/vault"
      tag: "v1.11.3"
    ha:
      raft:
        config: |
          listener "tcp" {
            address = "[::]:8200"
            cluster_address = "[::]:8201"
            tls_disable = true
          }
          storage "raft" {
            path = "/vault/data"
            retry_join {
              leader_api_addr = "http://${release_name}-vault-0.${release_name}-vault-internal:8200"
            }
          }
          service_registration "kubernetes" { }
