rime:
  # Global variables used by all rime services.
  domain: "${domain}"
  verbose: ${verbose}

  secrets:
    rimeLicense: ${rime_license}

  # Image parameters for images used by all rime services.
  images:
    imagePullSecrets:
      - name: ${docker_secret_name}
    backendImage:
      registry: "${docker_registry}"
      name: "${docker_image_names.backend}:${version}"
      pullPolicy: "${pull_policy}"
    frontendImage:
      registry: "${docker_registry}"
      name: "${docker_image_names.frontend}:${version}"
      pullPolicy: "${pull_policy}"
    modelTestingImage:
      registry: "${docker_registry}"
      name: "${docker_image_names.default_rime_image}:${version}"
      pullPolicy: "${pull_policy}"
    imageBuilderImage:
      registry: "${docker_registry}"
      name: "${docker_image_names.image_builder}:${version}"
      pullPolicy: "${pull_policy}"

  datasetManagerServer:
    enabled: ${blob_store_config.enable}
    config:
      storageBucketName: ${blob_store_config.s3_bucket_name}
      endpoint: "s3.amazonaws.com"
      type: "s3"
    serviceAccount:
      annotations: {
          eks.amazonaws.com/role-arn: ${blob_store_config.role_arn}
      }

  imageRegistryServer:
    enabled: ${image_registry_config != null}
%{ if image_registry_config != null ~}
    config:
      imageRegistry:
        baseImage:
          name: "${docker_registry}/${docker_image_names.base_rime_image}"
          registryType: dockerhub
%{ if image_registry_config.registry_type == "ecr" ~}
        ecr:
          registryID: "${image_registry_config.ecr_config.registry_id}"
          repositoryPrefix: "${image_registry_config.ecr_config.repository_prefix}"
%{ endif ~}
%{ if image_registry_config.registry_type == "gar" ~}
        gar:
          location: "${image_registry_config.gar_config.location}"
          project: "${image_registry_config.gar_config.project}"
          repository: "${image_registry_config.gar_config.repository}"
%{ endif ~}
    serviceAccount:
      annotations: {
        ${ image_registry_config.managed-image-repo-admin-annotation }
      }
    imageRegistryJob:
      dockerSecretName: "${docker_secret_name}"
      serviceAccount:
        annotations: {
          ${ image_registry_config.managed-image-repo-builder-annotation }
        }
%{ if separate_model_testing_group ~}
      tolerations:
        - key: "dedicated"
          operator: "Equal"
          value: "model-testing"
          effect: "NoSchedule"
      nodeSelector:
        dedicated: model-testing
%{ endif ~}
%{ endif ~}

%{ if separate_model_testing_group ~}
  modelTestingServer:
    modelTestingJob:
      tolerations:
        - key: "dedicated"
          operator: "Equal"
          value: "model-testing"
          effect: "NoSchedule"
      nodeSelector:
        dedicated: model-testing
%{ endif ~}

  ingress:
    annotations: {
      external-dns.alpha.kubernetes.io/hostname: "rime.${domain}"
    }

# Mongodb Subchart. See https://artifacthub.io/packages/helm/bitnami/mongodb for all parameters.
mongodb:
  replicaCount: 1
  image:
    registry: "${docker_registry}"
    repository: "robustintelligencehq/mongodb"
    tag: "5.0.9-debian-11-r7"
    pullSecrets:
      - ${docker_secret_name}
  persistence:
    storageClass: "${storage_class_name}"
    size: "${mongo_db_size}"
%{ if enable_mongo_tls ~}
  tls:
    image:
      registry: "${docker_registry}"
      repository: "robustintelligencehq/mongodb"
      tag: "5.0.9-debian-11-r7"
      pullSecrets:
        - ${docker_secret_name}
    enabled: true
    autoGenerated: false
    existingSecret: ${release_name}-mongo-bitnami-tls
%{ endif ~}

# Ingress-Nginx controller Subchart. See https://artifacthub.io/packages/helm/ingress-nginx/ingress-nginx for all parameters.
ingress-nginx:
  imagePullSecrets:
    - name: ${docker_secret_name}
  controller:
    image:
      registry: "${docker_registry}"
      image: "robustintelligencehq/ingress-nginx-controller"
      tag: "v1.3.1"
      digest: "sha256:d3642f55a6a7a102a9a579b3382fe73869c73890de4c94f28e36ba5e07925944"
    scope:
      enabled: true
      namespace: ${namespace}
    service:
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "${acm_cert_arn}"
        service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "https"
        service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "3600"
        service.beta.kubernetes.io/aws-load-balancer-type: "external"
        service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "tcp"
        service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: "ip"
        service.beta.kubernetes.io/aws-load-balancer-scheme: "${lb_type}"
%{ if length(lb_tags) > 0 ~}
      ${lb_tags}
%{ endif ~}
%{ if length(ip_allowlist) > 0 ~}
        service.beta.kubernetes.io/aws-load-balancer-target-group-attributes: preserve_client_ip.enabled=true
%{ endif ~}

# Redis Subchart. See https://artifacthub.io/packages/helm/bitnami/redis for all parameters.
redis:
  image:
    registry: "${docker_registry}"
    repository: "robustintelligencehq/redis"
    tag: "7.0.4-debian-11-r4"
  master:
    persistence:
      storageClass: "${storage_class_name}"
%{ if enable_redis_tls ~}
  tls:
    enabled: true
    authClients: true
    existingSecret: ${release_name}-redis-tls
    certFilename: "tls.crt"
    certKeyFilename: "tls.key"
    certCAFilename: "ca.crt"
%{ endif ~}

# Vault Subchart. See https://github.com/hashicorp/vault-helm for more information.
vault:
  global:
    imagePullSecrets:
      - name: ${docker_secret_name}
    tlsDisable: ${disable_vault_tls}
  server:
    # Use the opensource image instead of Enterprise Image
    image:
      repository: "${docker_registry}/robustintelligencehq/vault"
      tag: "v1.11.3"
    # Run Vault in "HA" mode.
    dataStorage:
      storageClass: "${storage_class_name}"
%{ if !disable_vault_tls ~}
    volumes:
      - name: ${release_name}-vault-tls
        secret:
          secretName: ${release_name}-vault-tls
    volumeMounts:
      - name: ${release_name}-vault-tls
        mountPath: "/var/tmp/vault-server-tls"
        readOnly: true
%{ endif ~}
    ha:
      raft:
        config: |
          listener "tcp" {
            address = "[::]:8200"
            cluster_address = "[::]:8201"
            tls_disable = ${disable_vault_tls}
%{ if !disable_vault_tls ~}
            tls_cert_file = "/var/tmp/vault-server-tls/tls.crt"
            tls_key_file  = "/var/tmp/vault-server-tls/tls.key"
            tls_client_ca_file = "/var/tmp/vault-server-tls/ca.crt"
%{ endif ~}
          }
          storage "raft" {
            path = "/vault/data"
            retry_join {
%{ if !disable_vault_tls ~}
              leader_api_addr = "https://${release_name}-vault-0.${release_name}-vault-internal:8200"
              leader_ca_cert_file = "/var/tmp/vault-server-tls/ca.crt"
              leader_client_cert_file = "/var/tmp/vault-server-tls/tls.crt"
              leader_client_key_file = "/var/tmp/vault-server-tls/tls.key"
%{ else ~}
              leader_api_addr = "http://${release_name}-vault-0.${release_name}-vault-internal:8200"
%{ endif ~}
            }
          }
          service_registration "kubernetes" { }

tls:
%{ if enable_cert_manager ~}
  vaultDisabled: ${disable_vault_tls}
  mongoEnabled: ${enable_mongo_tls}
  redisEnabled: ${enable_redis_tls}
  restEnabled: ${enable_rest_tls}
  grpcEnabled: ${enable_grpc_tls}
  crossplaneEnabled: ${enable_crossplane_tls}
  autorotateEnabled: ${enable_autorotate_tls}
%{ else ~}
  vaultDisabled: true
  mongoEnabled: false
  redisEnabled: false
  restEnabled: false
  grpcEnabled: false
  crossplaneEnabled: false
  autorotateEnabled: false
%{ endif ~}
  enableCertManager: ${enable_cert_manager}

external:
  vault: ${external_vault}
