# Value overrides created by the rime_agent terraform module.
%{ if false ~}
# NOTE TO DEVELOPERS: do NOT put default values here! Please put those values in the chart's values.yaml file
%{ endif ~}
rimeAgent:
%{ if length(datadog_tag_pod_annotation) > 0 ~}
  commonAnnotations:
    ad.datadoghq.com/tags: '${datadog_tag_pod_annotation}'
%{ endif ~}

  id: ${agent_id}

  existingSecretName: ${existing_api_key_secret_name}
  existingSigningKeySecretName: ${existing_signing_key_secret_name}

  images:
%{ if length(image_pull_secret_name) > 0 ~}
    imagePullSecrets:
      - name: ${image_pull_secret_name}
%{ endif ~}
    agentImage:
      registry: "${docker_registry}"
      name: "${image}:${version}"
    modelTestJobImage:
      registry: "${docker_registry}"
      name: "${default_rime_engine_image}:${version}"
%{ if generative_model_testing_config.enable ~}
    detectionEngineImage:
      registry: "${docker_registry}"
      name: "${generative_model_testing_config.detection_engine_image}:${generative_model_testing_config.firewall_version}"
%{ endif ~}

  connections:
  # Point the platform address directly at the NGINX ingress controller, so that
  # traffic for the internal agent does not leave the cluster.
%{ if enable_crossplane_tls ~}
    platformAddress: https://${ cp_nginx_controller_rest_addr }
%{ else ~}
    platformAddress: http://${ cp_nginx_controller_rest_addr }
%{ endif ~}

  rimeCrossPlaneServer:
    serviceAccount:
      name: ${ cross_plane_server_service_account_name }
      annotations: {
        eks.amazonaws.com/role-arn: ${ s3_reader_role_arn }
      }

  operator:
    logArchival:
      enabled: ${log_archival_config.enable}
%{if log_archival_config.enable ~}
      storageBucketName: ${log_archival_config.bucket_name}
      endpoint: ${log_archival_config.endpoint}
      type: ${log_archival_config.type}
    serviceAccount:
      # Account used by services that need access to blob storage.
      # This account has special privileges to read and write to S3 bucket used for blob storage.
      annotations: {
        eks.amazonaws.com/role-arn: ${log_archival_config.role_arn}
      }
%{ endif ~}
    modelTestJob:
      serviceAccount:
        name: ${ model_test_job_service_account_name }
        annotations: {
          eks.amazonaws.com/role-arn: ${ s3_reader_role_arn }
        }
%{ if separate_model_testing_group ~}
      tolerations:
        - key: "dedicated"
          operator: "Equal"
          value: "model-testing"
          effect: "NoSchedule"
      nodeSelector:
        dedicated: model-testing
%{ endif ~}

  detectionServer:
    enabled: ${generative_model_testing_config.enable}

%{if blob_store_config.enable ~}
fileServer:
  enable: true
  config:
    storageBucketName: ${blob_store_config.bucket_name}
    endpoint: "s3.amazonaws.com"
    type: "s3"
  serviceAccount:
    # Account used by services that need access to blob storage.
    # This account has special privileges to read and write to S3 bucket used for blob storage.
    annotations: {
      eks.amazonaws.com/role-arn: ${blob_store_config.role_arn}
    }
%{ endif ~}
tls:
%{ if enable_cert_manager ~}
  crossplaneEnabled: ${enable_crossplane_tls}
%{ else ~}
  crossplaneEnabled: false
%{ endif ~}
  enableCertManager: ${enable_cert_manager}

ri-detection-resources:
  enabled: ${generative_model_testing_config.enable}

  images:
    modelServerImage:
      registry: "${docker_registry}"
      name: "${generative_model_testing_config.model_server_image}:${generative_model_testing_config.firewall_version}"
    firewallBackendImage:
      registry: "${docker_registry}"
      name: "${generative_model_testing_config.firewall_backend_image}:${generative_model_testing_config.firewall_version}"

  secrets:
    existingIntegrationSecretsName: "${generative_model_testing_config.secret_name}"

supportBundle:
  enabled:  ${enable_support_bundle}
